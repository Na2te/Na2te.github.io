---
layout: post
title: 19. 극한의 상황에서도 값 보존하기
categories: [study, android]
tags: [blog]
---

- toc
{:toc .large-only}

## 값 보존하기

`안드로이드 앱`은 **안드로이드**라는 `OS`환경의 `디바이스`에서 <mark>설치되어 돌아가는 프로그램</mark>이다.

`안드로이드`는 `메모리 부족`과 같은 **디바이스의 상황**에 따라서 **프로세스를 내리는 등**의 `OS`로서의 **역할**을 수행하기 때문에 앱을 개발하면서 특히 이러한 부분의 고려를 생각해야 한다.

그렇지 않다면 **겉보기에는 멀쩡하지만 툭하면 예상대로 안돌아가는 앱**이 만들어지고, `코드는 문제 없는데 왜 안되는거야?`와 같은 상황이 오기 일쑤다.

이러한 부분에서 생각해보자면 **안드로이드에서 크게 생각할만한 부분**은 `Configuration Change`와 `Process Kill` 정도다.

+ ### Configuration Change

  한국어로 구성 변경으로 구성 변경은 **기기 상태가 매우 급격하게 변경되어 시스템이 변경사항을 확인하는 가장 쉬운 방법이 활동을 완전히 종료하고 다시 빌드하는 것일 때 발생**한다.

  + #### 대표적 상황
    + 앱 디스플레이 크기가 달라졌을 때 (폴드의 외부 디스플레이로 쓰다가 화면을 펼쳤을 때 같은)
    + 화면 방향 전환 (가로, 세로)
    + 글꼴 크기 및 두께
    + 언어
    + 다크/라이트 모드

  이러한 `구성 변경`이 발생되면 `Activity`는 생명주기 상 `onDestroy`까지 호출되어 **종료되었다가 다시 실행되게 된다.**

  그렇기 때문에 `Activity`, `Fragment`에 **값을 선언 및 저장한 후 그것을 UI에 뿌릴 데이터로 사용하게 되면**, 화면 전환 등 **구성 변경이** 생길 때마다 값이 날라갔다가 **다시 초기화 되버리는 상황이 나온다.**

  ```kotlin
  // file: "MainActivity.kt"
  @AndroidEntryPoint
  class MainActivity : ComponentActivity() {
      override fun onCreate(savedInstanceState: Bundle?) {
          super.onCreate(savedInstanceState)
          enableEdgeToEdge()
          var cnt by mutableIntStateOf(0)
          setContent {
              RestoreTheme {
                  Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding ->
                    ActivityScreen(
                        modifier = Modifier.padding(innerPadding),
                        cnt = cnt,
                        onClickIncrement = { cnt++ }
                    )
                  }
              }
          }
      }
  }

  @Composable
  fun ActivityScreen(modifier: Modifier = Modifier, cnt: Int, onClickIncrement: () -> Unit) {
      Column(modifier = modifier){
          Text("Total Cnt : $cnt")
          Button(
              modifier = modifier,
              onClick = onClickIncrement
          ) {
              Text("Cnt ++ Button")
          }
      }
  }
  ```

  이런 간단한 버튼 누른 횟수를 보여주는 앱을 만들었을 때 버튼을 누를 때마다 횟수가 늘어나는 것이 잘 반영되지만 **화면 전환과 같은 구성 변경이 발생하면 값이 초기화 된다.**

  <video width="800" src="/assets/img/study/android/극한의%20상황에서도%20값%20보존하기/액티비티%20값%20날라감.mp4" style="display:block; margin-bottom:10px;  margin-left: auto; margin-right: auto;" alt="뚝딱" controls></video>구성 변경이 일어날 때마다 값이 날아가는 것을 볼 수 있다
  {:.figcaption}

+ ### 선언별 차이

  이러한 값 손실을 막기 위한 방법으로는 다양하게 있다.

  `ViewModel`에 데이터를 저장하면 `Activity`가 **destroy 되더라도** `ViewModel`은 **파괴되지 않고 유지된다.**
  
  **단 중요한 점은 `ViewModel`을 정상적인 방법으로 호출해야 한다는 것이다.**

  ```kotlin
  class MainActivity : AppCompatActivity() {
      // 잘못된 호출
      val restoreViewModel: RestoreViewModel  = RestoreViewModel()

      override fun onCreate(savedInstanceState: Bundle?) {
          super.onCreate(savedInstanceState)
          // ...
      }
  }
  ```

  위와 같이 **생성자를 직접 호출하는 식으로 부르게 될 경우**, **구성 변경**이 일어났을 때 `ViewModel`은 위의 버튼 클릭 예제와 마찬가지로 **`onDestroy`될 때 사라졌다가, `onCreate`시 다시 호출되면서 `Activity`에서 선언하는 것과 다를 바가 없게 되어버린다.**

  올바른 호출 방식은 `ViewModelStoreOwner`를 바탕으로 생성을 하는 것이고, `ViewModelProvider`를 통해서 구현을 할 수 있는데 이를 `by viewModels()`로 간단하게 부를 수 있다.

  또한 `Composable`의 인자로 `ViewModel`을 부르는 경우 `viewModel()`함수로 부를 수 있고 아래처럼 `LocalViewModelStoreOwner`를 가져와서 세팅한다.

  ![Composable ViewModel](/assets/img/study/android/극한의%20상황에서도%20값%20보존하기/ComposableViewModel.png){: loading="lazy"}
  내부 구현 코드
  {:.figcaption}


  참고로 `ViewModelStoreOwner`는 `getViewModelStore` 메서드를 가지는 `Interface`로 `ViewModelStore`를 가지게 되며 이는 `String`을 `Key`로, `ViewModel`을 `value`로 가지는 `Map`을 가지고 있다.

  ![ViewModelStoreOwner 일부](/assets/img/study/android/극한의%20상황에서도%20값%20보존하기/VIewModelStoreOwner.png){: loading="lazy"}
  ViewModelStoreOwner 일부
  {:.figcaption}

  ![ViewModelStore 구조](/assets/img/study/android/극한의%20상황에서도%20값%20보존하기/ViewModelStore구조.png){: loading="lazy"}
  ViewModelStore 구조
  {:.figcaption}

  어쨌거나 이를 통해 `ViewModel`은 기본적으로 **자신을 호출한 컴포넌트의 생명주기에 종속되는데도 불구하고**, `Activity`가 **`Destroy`될 때 파괴되지 않을 수 있는 이유는 Acitivity 등의 로직에 있다**

  `ComponentActivity`의 코드의 일부를 보면 아래와 같이 `OnDestroy`이벤트가 일어났을 경우 `ConfigurationChange` 유무에 따라서 분기처리를 하고 결론적으로 `Configuration Change`가 아닐 경우에는 `ViewModelStore`의 `clear`함수를 호출하지 않고 Destroy한다.

  이 `Configuration Change`의 여부는 시스템에서 파악하며 이를 바탕으로 `Activity`가 직접 `finish`처럼 명시적으로 종료가 호출된 코드와 `ViewModel`의 생존이 결정되게 된다.


  다시 정리하자면 결국 이 차이로 인해 `Activity`에 변수를 넣었을 때와는 다르게 **`ViewModel`에 변수를 넣고서 불러올 경우** 화면 전환과 같은 **구성 변경에서도 손실되지 않고 값을 계속해서 유지할 수 있다.**


  <mark>다만 이건 어디까지나 구성 변경에 한해서 통용되는 이야기다.</mark>

  `Android` 단말기는 사용자가 `A` 앱을 실행시키고 있었다고 하더라도 전화가 오면 `A` 앱은 백그라운드로 밀리기 때문에 **언제든지 어떤 앱이든 백그라운드로 돌아갈 가능성이 있으며** <mark>백그라운드는 포그라운드에 비해 우선 순위가 낮아</mark> **메모리가 부족해질 시 Kill될 가능성이 높아지기 때문에** <mark>우리가 실행하는 모든 앱은 항상 언제든지 OS에 의해 Kill될 염두에 두고 있어야 하며 그럼에도 불구하고 다시 돌아왔을 때 자연스럽게 이어 진행할 수 있어야 한다.</mark>

  그리고 결론적으로 `ViewModel`은 이러한 상황에서 해결책이 되어주진 않는다.

  어디까지나 `ViewModel`은 `Activity`가 `Destroy`될 때에도 죽지 않고 메모리에 살아 있는 것 뿐이기에 메모리가 부족해서 `Process`가 `Kill`되거나, `Exception`이 발생하는 등 `Process`가 종료되고 **메모리에서 회수되는 경우** `ViewModel` 또한 당연히 사라지게 된다.

  만약 최악의 경우 중요한 작업을 하고 있다가 전화가 와서 전화를 받고 돌아왔더니 앱이 `Kill` 되어서 `Refresh`되면서 `ViewModel `에서 관리 중이던 데이터가 전부 날아갔다면? 상당한 문제가 될 것이다.

  기본적으로 이러한 문제점은 **데이터가 앱 프로세스의 메모리에 상주하기 때문에 생기는 문제**이기 때문에, 결론적으로 **`Disk`에 저장해서 기록하면 된다.**

  `Android`에서는 이러한 경우를 위해서 `SavedStateHandle`을 제공한다.


  정확히는 `Activity`에서는 `onSaveInstance`에서 `Bundle`에 값을 `Key - Value` 형식으로 저장하여 `Android System`에 의해서 `Process`가 `Kill`되었을 때 다시 복구할 수가 있는데, `ViewModel`의 데이터를 `Activity`의 `onSaveInstance`에서 저장할 필요 없이 저장하기 위한 방식이다.





  결론적으로 이는 